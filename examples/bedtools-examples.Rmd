---
title: "Using plyranges to analyse bed files."
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(magrittr)


devtools::load_all("../")
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API.

## Data
The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

## Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function.
```{r}
exons <- read_bed(exons_bed, genome_info = "hg19")
exons
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `compute_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `compute_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}

cvg <- exons %>% 
  compute_coverage() %>% 
  filter(score > 0)

cvg
```

## Coverage histogram

We can construct a histogram over all seqeunces 
using the `group_by` and `summarise` operations. First, we compute the 
coverage and add the sequence lengths as a column.  

To summarise the coverage histogram within each chromosome we use the 
`group_by` and `summarise` operations. 
```{r cv-hist}
cvg <- exons %>% 
  compute_coverage() %>% 
  set_genome_info(seqlengths)

cvg_hist_by_seq <- cvg %>%   
  group_by(seqnames, score) %>%
  summarise(count = length(score),
            .seqlengths = unique(.seqlengths)) %>% 
  mutate(fraction = count / .seqlengths)

cvg_hist_total <- cvg %>%
  mutate(.seqlengths = sum(unique(as.numeric(.seqlengths)))) %>% 
  group_by(.seqlengths, score) %>% 
  summarise(count = length(score)) %>% 
  mutate(fraction = count / .seqlengths,
         seqnames = "genome")

cvg_hist <- bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

## Chaining example 

Here we perform another example where we chain a filter with a mutate. In
this example we are performing a filtering step and then find overlap pairs
between the input exon ranges and the cpg islands. 

```{r}
genome <- import(paste0(data_dir, "hg19.genome"))

cpg_query <- BEDFileQuery(paste0(data_dir, "cpg.bed")) %>% 
  import(genome = NA_character_) 
exons_query <- BEDFileQuery(paste0(data_dir, "exons.bed")) %>% 
  import(genome = genome) %>% 
  filter(score == 0L)

overlaps <- inner_ojoin(exons_query, cpg_query) 
overlaps
```

## Examples from Lawrence and Morgan 2014

Lawrence, M. & Morgan, M. Scalable Genomics with R and Bioconductor. Stat. Sci. 29, 214â€“226 (2014).
