---
title: "Using plyranges to analyse bed files."
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(magrittr)


devtools::load_all("../")
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API.

## Data
The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

## Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function.
```{r}
exons <- read_bed(exons_bed, genome_info = "hg19")
exons
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `set_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `set_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}

cvg <- exons %>% 
  set_coverage() %>% 
  filter(score > 0)

cvg
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations. First, we compute the 
coverage and add the sequence lengths as a column.  

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Similarly for the genome-wide 
coverage histogram, we compute the entire size of the sequence length  and 
perform the same operation. Finally we bind the result `tibbles` together.
Note that in the sums we have coerced integer variables to doubles to avoid 
overlfow.
```{r cv-hist}
cvg <- exons %>% 
  set_coverage() %>% 
  set_genome_info(seqlengths)

cvg_hist_by_seq <- cvg %>%   
  group_by(seqnames, .seqlengths, score) %>%
  summarise(count = sum(as.numeric(width))) %>%
  mutate(fraction = count / .seqlengths)

cvg_hist_total <- cvg %>%
  mutate(.seqlengths = sum(unique(as.numeric(.seqlengths)))) %>% 
  group_by(.seqlengths, score) %>% 
  summarise(count = sum(as.numeric(width))) %>% 
  mutate(fraction = count / .seqlengths,
         seqnames = "genome")

cvg_hist <- dplyr::bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

## Overlaps example

Here we perform another example where we chain a filter and then
find overlapping ranges between two ranges. In
this example we reduce the exons to have zero and then find the ranges that
overlap between the filtered exon ranges and the cpg islands. 

```{r}
cpg <- read_bed(cpg_bed, genome_info = "hg19")

overlaps <- ojoin_inner(exons %>% filter(score == 0L), 
                        cpg) 
overlaps %>% 
  set_coverage() %>% 
  mutate(count = sum(as.numeric(width)))
  
```

## Examples from Lawrence and Morgan 2014

Lawrence, M. & Morgan, M. Scalable Genomics with R and Bioconductor. Stat. Sci. 29, 214â€“226 (2014).
