---
title: "Using plyranges to analyse bed files."
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
devtools::load_all("../")
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API. Throughout this tutorial we will highlight how
the `bedtools`, `HelloRanges` and `plyranges` API differ. 

The `plyranges` API attempts to be type-consistent, that is if you apply
a `plyranges` function to a _Ranges_ object it should return a _Ranges_ object.
This means that intermittant Bioconductor classes such as `Rle` objects are
hidden away from the user, and the user can focus on the table-like structure
of ordinary _Ranges_ objects. A _Ranges_ object, in particular a _GRanges_ object
resembles a BED file and has columns to represent the chromomsome, start, end,
and strand information. It can also contain additional columns called metadata
containing information about the rows (i.e an exon name or a measurement).

## Data
The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

## Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function, allowing
us to obtain annotation information about each chromosome.
```{r}
exons <- read_bed(exons_bed, genome_info = "hg19")
exons

cpg <- read_bed(cpg_bed, genome_info = "hg19")
cpg
```

# Intersections and Overlaps

A useful operation on two _Ranges_ is to identify where they intersect. By 
default `bedtools` will return the region of intersection between two genomic
tracks. In `plyranges` the intersect operation is a type of overlap join, that is
we are finding the common genomic intervals that overlap between the two tracks.

In `plyranges` this is termed an left overlap join:
```{r}
intersect <- ojoin_inner(cpg, exons)
intersect
```

In the `HelloRanges` API (we also see the `bedtools` code here) the equivalent 
operation is:
```{r}
library(HelloRanges)
code <- bedtools_intersect("-a cpg.bed -b exons.bed -g hg19")
code
```

## Keeping the original features
Using a `left_join` keeps the features present in both ranges.
```{r}
# need to add suffix operation here
intersect_features <- left_join(intersect, exons)
intersect_features 
```

## Computing the amount of overlap
To compute the amount of overlap we store the width of the intersecting ranges
as an additional column using the `mutate` operator.
```{r}
intersect_features <- intersect_features %>% 
  mutate(overlap_width = width)
```

The equivalent bedtools/HelloRanges command is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -wo")
```

## Counting the number of overlaps
To add the count of the number of times each cpg island overlaps an exon we can
use `mutate` with the `count_overlaps` function.

```{r}
cpg %>% 
  mutate(overlaps = count_overlaps(., exons))
```

The equivalent bedtools operation is

```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -c")
```

## Excluding by overlaps

We can use `filter` along with the infix operator `%over` to only
include CpG islands that do not overlap any exons.
```{r}
cpg %>% 
  filter(!(. %over% exons))

```

The equivalent bedtools operation is
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -v")
```

## Excluding by fraction of overlap

A common operation is to filter ranges by the fraction they overlap a
given query or subject. We can achieve this with a left overlap join
an inner overlap join and a filter.

```{r}
# not happy with accessor use here
overlap_intersect <- ojoin_inner(cpg, exons) %>% 
  mutate(olap_width = width(ojoin_left(cpg, exons))) %>% 
  filter(width / olap_width >= 0.5)

```

The equivalent bedtools code is
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -f 0.5 -wo")
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `set_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `set_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}

cvg <- exons %>% 
  set_coverage() %>% 
  filter(score > 0)

cvg
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations along with
`left_join`. First, we compute the 
coverage over the exons and construct a `tibble` with sequence lengths 
as a column.  

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Then we join the resulting `tibble`
to the annotation `tibble` called `hg19`. Note that in the sums we have coerced integer variables to doubles to avoid 
overflow.

Similarly for the genome-wide 
coverage histogram, we perform the same operation but do not group over
`seqnames`. Finally we bind the resulting `tibbles` together.

```{r cv-hist}
cvg <- exons %>% set_coverage()
hg19 <- get_genome_info(cvg) %>% 
  select(seqnames, width)

cvg_hist_by_seq <- left_join(cvg %>%   
                               group_by(seqnames, score) %>%
                               summarise(count = sum(as.numeric(width))),
                             hg19,
                             by = "seqnames") %>% 
  mutate(fraction = count / lengths)

cvg_hist_total <- left_join(cvg %>%
                              group_by(score) %>% 
                              summarise(count = sum(as.numeric(width))) %>% 
                              mutate(seqnames = "genome"),
                            hg19 %>% 
                              summarise(width = sum(as.numeric(width))) %>% 
                              mutate(seqnames = "genome"))

cvg_hist <- dplyr::bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

## Overlaps example

Here we perform another example where we chain a filter and then
find overlapping ranges between two ranges. In
this example we reduce the exons to have zero and then find the ranges that
overlap between the filtered exon ranges and the cpg islands. 

```{r}
cpg <- read_bed(cpg_bed, genome_info = "hg19")

overlaps <- ojoin_inner(exons %>% filter(score == 0L), 
                        cpg) 

overlaps
  
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf. 
```{r}
cvg_over_exons <- exons %>% 
  set_coverage() %>%
  ojoin_inner(., cpg) %>%
  mutate(total = sum(as.numeric(width))) %>% 
  group_by(score) %>%
  summarise(count = sum(as.numeric(width)),
            fraction = count / unique(total)) 

library(ggplot2)
ggplot(cvg_over_exons, aes(x = score, y = 1 - cumsum(fraction))) +
  geom_step() +
  xlim(c(0,25))  +
  xlab("coverage") +
  ylab("fraction of bp > coverage")
```
