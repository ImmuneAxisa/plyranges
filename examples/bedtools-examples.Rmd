---
title: "Using plyranges to analyse bed files."
author: "Stuart Lee"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(dplyr)
library(magrittr)


devtools::load_all("../")
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API.

## Data
The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

## Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function.
```{r}
exons <- read_bed(exons_bed, genome_info = "hg19")
exons
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `compute_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `compute_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}

cvg <- exons %>% 
  compute_coverage() %>% 
  filter(score > 0)

cvg
```

## Coverage histogram


We can construct a histogram over all seqeunces 
using the `group_by` and `summarise` operations. In order to get the total
coverage we evaluate the query and then resummarise it using `dplyr`.

```{r cv-hist}
exons %>% 
  compute_coverage() %>% 
  group_by(seqnames, score) %>% 
  summarize(count = sum(score))
```

A disadvantage of this approach is having to perform a join within the first
mutate in order to keep the length of the sequences for downstream computation.

```{r query-cvhist}
genome <- import(paste0(data_dir, "hg19.genome"))

exons_query <- BEDFileQuery(paste0(data_dir, "exons.bed")) %>% 
  import(genome = genome) %>% 
  mutate(cov = compute_coverages(gr_a))
exons_query


covhist <- left_join(exons_query, genome) %>%
  group_by(seqnames, seqlengths, score) %>% 
  summarise(count = sum(score)) %>% 
  mutate(fraction = count / seqlengths) %>% 
  ungroup()

# genome-wide  
covhist_total <- covhist %>% 
  group_by(score) %>% 
  summarise(count = sum(as.numeric(count)), 
            seqlengths = sum(as.numeric(seqlengths)))  %>% 
  mutate(seqnames = "genome", fraction = count / seqlengths)


covhist <- bind_rows(covhist, covhist_total)

head(covhist)
tail(covhist)
```

## Chaining example 

Here we perform another example where we chain a filter with a mutate. In
this example we are performing a filtering step and then find overlap pairs
between the input exon ranges and the cpg islands. 

```{r}
genome <- import(paste0(data_dir, "hg19.genome"))

cpg_query <- BEDFileQuery(paste0(data_dir, "cpg.bed")) %>% 
  import(genome = NA_character_) 
exons_query <- BEDFileQuery(paste0(data_dir, "exons.bed")) %>% 
  import(genome = genome) %>% 
  filter(score == 0L)

overlaps <- inner_ojoin(exons_query, cpg_query) 
overlaps
```

## Examples from Lawrence and Morgan 2014

Lawrence, M. & Morgan, M. Scalable Genomics with R and Bioconductor. Stat. Sci. 29, 214â€“226 (2014).
