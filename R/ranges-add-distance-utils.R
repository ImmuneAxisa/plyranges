#' Add suffix to column name
#' 
#' I think dplyr::add_count will change how they add names in 1.0.0
#' used to it would add n until it got a unique name
#' I can't find the blogpost describing the new behavior,
#' but it may be good to mirror whatever that is here.
#' For now, just recursively add suffix until a unique column is found
#'
#' @param name column name to add
#' @param suffix suffix to use
#' @param names names of data.frame in which to add new column
#'
#' @return a unique name generated by prepending suffix recursively until
#'     a unique name is found
#' @noRd
add_colname_suffix <- function(name, suffix, names){
  
  stopifnot(length(suffix) == 1)
  
  if (name %in% names) {
    name <- paste0(name, suffix)
  } else {
    return(name)
  }
  add_colname_suffix(name, suffix, names)
}

#' @param ranges ranges object from join_nearest expand_hits internal function
#'
#' @param hits  hits from distanceToNearest
#' @param colname name of column to hold distance values
#' @param suffix suffix to add to colname if exists
#'
#' @noRd
add_distance_col <- function(ranges, hits, colname = "distance", suffix = ".y"){
  UseMethod("add_distance_col")
}

#' @noRd
add_distance_col.GenomicRanges <- function(ranges, hits, colname = "distance", suffix = ".y"){
  
  if (!("distance" %in% names(mcols(hits)))) {
    stop("hits object must contain a distance column")
  }
  
  colname <- add_colname_suffix(colname, suffix, names(mcols(ranges)))
  
  # This is to fix a failure with upstream/downstream joins if using add_dist_or_NA
  # Ranges & hits should only be same length if they've undergone a join operation,
  # in which case the order should correspond to query regions anyway 
  # (this was old default behavior)
  if (length(ranges) == length(hits)){
    mcols(ranges)[colname] <- mcols(hits)$distance
  } else {
    # This allows add_nearest_distance_* family functions to work
    # by adding an NA if there is no nearest feature
    ranges <- add_distance_or_NA(ranges, hits, colname)
  }
  
  return(ranges)
}

#' @noRd
add_distance_col.IRanges <- function(ranges, hits, colname = "distance", suffix = ".y"){
  
  if (!("distance" %in% names(mcols(hits)))) {
    stop("hits object must contain a distance column")
  }
  
  colname <- add_colname_suffix(colname, suffix = suffix, names(mcols(ranges)))
  
  # initialize distance col with NA_integer_ if no metadata exists
  # must do this because setting mcols() when empty on IRanges fails
  if (is.null(mcols(ranges))){
    metadata <- DataFrame("distance" = NA_integer_)
    names(metadata) <- colname
    mcols(ranges) <- metadata
  } 
  
  if (length(ranges) == length(hits)){
    mcols(ranges)[colname] <- mcols(hits)$distance
  } else {
    ranges <- add_distance_or_NA(ranges, hits, colname)
  }
  
  return(ranges)
}

add_distance_or_NA <- function(query, hits, colname = "distance"){
  # Problem: if ranges don't have nearest entry, hits object will be incomplete
  # Solution: add distance by queryHits
  # set NA if not present
  mcols(query)[colname] <- NA_integer_
  mcols(query[queryHits(hits)])[colname] <- mcols(hits)$distance
  return(query)
}

