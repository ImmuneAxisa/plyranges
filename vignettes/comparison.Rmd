---
title: "Using plyranges to perform common genomic data wrangling tasks"
author: "Stuart Lee"
package: plyranges
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::md_document:
    variant: markdown_github
abstract: A fluent interface to `Ranges` classes.
vignette: >
  %\VignetteIndexEntry{data-wrangling}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API. Throughout this tutorial we will highlight how
the `bedtools`, `HelloRanges` and `plyranges` API differ. 

The `plyranges` API attempts to be type-consistent, that is if you apply
a `plyranges` function to a _Ranges_ object it should return a _Ranges_ object.
This means that intermittant Bioconductor classes such as `Rle` objects are
hidden away from the user, and the user can focus on the table-like structure
of ordinary _Ranges_ objects. A _Ranges_ object, in particular a _GRanges_ object
resembles a BED file and has columns to represent the chromomsome, start, end,
and strand information. It can also contain additional columns called metadata
containing information about the rows (i.e an exon name or a measurement).

# Data

The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

# Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function, allowing
us to obtain annotation information about each chromosome.
```{r}
suppressPackageStartupMessages(library(plyranges))
cpg <- read_bed(cpg_bed, genome_info = "hg19")
cpg

exons <- read_bed(exons_bed, genome_info = get_genome_info(cpg))
exons
```

# Intersections and Overlaps

A useful operation on two _Ranges_ is to identify where they intersect. By 
default `bedtools` will return the region of intersection between two genomic
tracks. In `plyranges` the intersect operation is a type of overlap join, that is
we are finding the common genomic intervals that overlap between the two tracks.

In `plyranges` this is termed an intersect overlap join:
```{r}
intersect_rng <- join_overlap_intersect(cpg, exons)
intersect_rng
```

In the `HelloRanges` API (we also see the `bedtools` code here) the equivalent 
operation is:
```{r}
suppressPackageStartupMessages(library(HelloRanges))
code <- bedtools_intersect("-a cpg.bed -b exons.bed -g hg19")
code
```

## Keeping the original features
By default an overlap join will keep the information in both the query and
subject ranges.

## Computing the amount of overlap
To compute the amount of overlap we store the width of the intersecting ranges
as an additional column using the `mutate` operator.

```{r}
intersect_rng <- intersect_rng %>% 
  mutate(overlap_width = width)
```

The equivalent bedtools/HelloRanges command is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -wo")
```

## Counting the number of overlaps
To add the count of the number of times each cpg island overlaps an exon we can
use `mutate` with the `count_overlaps` function.

```{r}
cpg %>% 
  mutate(overlaps = count_overlaps(., exons))
```

The equivalent bedtools operation is

```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -c")
```

## Excluding by overlaps

We can use `filter_by_non_overlaps` to include CpG islands that do not overlap 
any exons.
```{r}
cpg %>% 
  filter_by_non_overlaps(., exons)
```

The equivalent bedtools operation is
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -v")
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `compute_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `compute_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}
cvg <- exons %>% 
  compute_coverage() %>% 
  filter(score > 0)
cvg

bedtools_genomecov("-i exons.bed -g hg19.genome -bg")
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations along with
`left_join`. 

First, we compute the 
coverage over the exons and construct a `DataFrame` from the genome build 
information using `select` with `.drop_ranges = FALSE`.

```{r cv-hist0}
suppressPackageStartupMessages(library(dplyr))
cvg <- exons %>% compute_coverage()
# convert the sequence annotation to a data.frame 
hg19 <- get_genome_info(cvg) %>%  
 select(seqnames, width, .drop_ranges = TRUE) %>%
  as.data.frame()
```

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Then we join the resulting `tibble`
to the annotation `tibble` called `hg19`. Note that in the sums we have coerced integer variables to doubles to avoid overflow.

```{r cv-hist1}

cvg_hist_by_seq <- cvg %>%
  group_by(seqnames, score) %>%
  summarise(count = sum(as.numeric(width))) %>% 
  as.data.frame() %>%
  left_join(., hg19) %>% 
  mutate(fraction = count / width)

cvg_hist_by_seq

```

Similarly for the genome-wide 
coverage histogram, we perform the same operation but do not group over
`seqnames`. Finally we bind the resulting `tibbles` together.

```{r cvhist2}
cvg_hist_total <- cvg %>%
  group_by(score) %>% 
  summarise(count = sum(as.numeric(width))) %>%
  as.data.frame() %>%
  mutate(seqnames = "genome") %>%
  left_join(.,
            hg19 %>% 
              summarise(width = sum(as.numeric(width))) %>% 
              mutate(seqnames = "genome") %>%
              as.data.frame()) %>%
  mutate(fraction = count / width)

cvg_hist_total

cvg_hist <- bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

Although this is slightly more verbose than the `bedtools` or `HelloRanges` approach the `plyranges` code makes the actions being performed on the input
`Ranges` explicit:

```{r}
bedtools_genomecov("-i exons.bed -g hg19.genome")
```

# Composing pipelines 

## Yet another overlaps example

Here we perform another example where we find exons with no coverage that
overlap cpg islands. To compose a chain first we compute the coverage
then use a filter to restrict to zero coverage ranges. Then we
perfrom an inner overlap join to find which cpg islands overlap the exonic
regions with zero coverage.

```{r}
overlaps <- exons %>% 
  compute_coverage() %>% 
  filter(score == 0L) %>% 
  join_overlap_intersect(.,  cpg) 

overlaps
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf.

```{r}
cvg_over_exons <- exons %>% 
  compute_coverage() %>%
  join_overlap_inner(., cpg) %>%
  mutate(total = sum(as.numeric(width))) %>% 
  group_by(score) %>%
  summarise(count = sum(as.numeric(width)),
            fraction = count / unique(total)) 

cvg_over_exons

plot(1 - cumsum(fraction) ~ score, data = cvg_over_exons, 
     xlim = c(0,25), 
     type= "s", 
     xlab = "coverage", 
     ylab = "fraction of bp > coverage")

```



# Mapping to GenomicRanges/IRanges

For users already familiar with the `IRanges` and `GenomicRanges` we provide 
mappings to the  `plyranges` API. 

## Operations on range width 

 For `G`Ranges`` objects all functions ignore
any strandedness, unless the strand of the range is anchored.

| `plyranges` functions | Description | `GenomicRanges/IRanges` command |
|-----------------------|-------------|---------------------------------|
| `anchor_(start/end/center/3p/5p)` | Fix the `start/end/center/` coordinates or positive/negative strand of range. Can be used in combination with any of the following   | Available in functions that have a `fix` argument. |
| `set_width(x, width)` | Modify the width of a `Ranges` | `resize` |
| `stretch(x, extend)` | Extend the start and end coordinates in opposite directions by a fixed amount. | `start(x)<- start(x) + extend%/%2`, `end(x) <- end(x) -extend%/%2` |

## Operations on range width (invariant) 

| `plyranges` functions | Description | `GenomicRanges/IRanges` command |
|-----------------------|-------------|---------------------------------|
| `shift_[left/right/downstream/upstream](x, shift)` | Shift the coordinates of the interval (left/right/downstream/upstream) by an integer amount.    | `shift_right` corresponds to `shift` |
| `flank_[left/right/downstream/upstream](x, width)` | Generates flanking regions of size width `left/right/downstream/upstream/` | corresponds to `flank` |

## Set operations (vector wise)

These are usual set-operations that act on the sets of the
`Ranges` represented in x and y. By default these operations will ignore
any strand information. The directed versions of these functions will
take into account strand.

| `plyranges` functions | Description | `GenomicRanges/IRanges` command |
|-----------------------|-------------|---------------------------------|
| `[intersect/setdiff/union/]_Ranges` | Set operations between two `Ranges`, ignoring strand. | `intersect/setdiff/union/` with `ignore.strand = FALSE` |
| `[intersect/setdiff/union/]_anchored_Ranges` | As above taking into account strandedness. | 

## Set operations (element wise)

We provide infix operators and the verbs between and span to the represent element wise range operations. These
map to the `pintersect/punion/psetdiff/pgap/punion(fill.gap = FALSE)` functions.

## Restrictions

The verb `filter` corresponds to `subset`, while `filter_by_[overlaps/non_overlaps]` corresponds to `subsetByOverlaps`.

## Aggregation

The `summarise` verb is most similar to the `aggregate` methods defined in `GenomicRanges/IRanges`. 

The `reduce_ranges/disjoin_ranges` correspond to the `reduce/disjoin` methods. 
However, the former methods allow additional summarisation. 

The `compute_coverage(x)` method corresponds to `[I/G]Ranges(coverage(x))`. 

## Overlaps

 For `GRanges` objects all functions ignore
any strandedness, unless the suffix `directed` is added to the funciton call

| `plyranges` function                     | Description                                                                                 | `GenomicRanges/IRanges` command  |
|------------------------------------------|---------------------------------------------------------------------------------------------|---------------------------------|
| `find_overlaps(x, y, maxgap, minoverlap)`|  Returns a `Ranges` object with any range in `y` that overlaps `x`. Appends the metadata in `y` and its genomic intervals to the returning `Ranges`. | `findOverlaps(x,y, maxgap, minoverlap, type = "any")` with expanding `x` and `y` by their hits and appending the `mcols` in `y`. | 
| `group_by_overlaps(x, y, maxgap, minoverlap)` | Returns a GroupedRanges object grouped by the query hits. |  Same as above with an additional column called `query` which contains the queryHits. |
| `count_overlaps(x, y, maxgap, minoverlap)` | Returns an integer vector (used with `mutate`) | `countOverlaps(x, y, maxgap, minoverlap, type = "any")` |
| `join_overlap_self(x, maxgap, minoverlap)` |  Returns a `Ranges` object with any range that overlaps itself. | `findOverlaps(x,x, maxgap, minoverlap, type = "any")`|
| `join_overlap_inner(x, y, maxgap, minoverlap)` | Finds the intersecting `Ranges` that overlap in `x` and `y`. Returns a `Ranges` object with the metadata from `x` and `y`.  |  `findOverlapsPairs(x,y, maxgap, minoverlap, type = "any")` + `pintersect`. |               | `join_overlap_left(x, y, maxgap, minoverlap)` | Identical to `find_overlaps`  | Identical to `find_overlaps`. |                   
| `*_within` | Adding suffix `within` will find overlaps   | Makes `type = "within"` |
| `*_includes` | inverse of within functions | - |
| `join_nearest[_left/right/up/downstream](x,y)` | Finds nearest neighbour `Ranges` between `x` and `y`. | `nearest` + reindexing to return a `Ranges` object. |
|`join_precede[_left/right/up/downstream](x,y)`  | Finds `Ranges` in `x` that preced `y` | `precedes` + reindexing to return a `Ranges` object. |
|`join_follow[_left/right/up/downstream](x,y)`  | Finds `Ranges` in `x` that follow `y`  | `precedes` + reindexing to return a `Ranges` object. |
