---
title: "Introduction to the plyranges package"
author: "Stuart Lee"
package: plyranges
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::md_document:
    variant: markdown_github
abstract: A fluent interface to `Ranges` classes.
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

# Introduction

The `plyranges` package provides a 
[fluent](https://en.wikipedia.org/wiki/Fluent_interface) interface for 
performing common genomic data analysis tasks. One goal of this package is to 
decrease the learning curve for Bioconductor and S4 classes 
(especially for new users) by providing a consistent interface to 
common classes, `IRanges` and `GRanges` classes. 

This document provides an overview of some of the features of the `plyranges`
grammar for analysing genomic data. I give a brief introduction
to the `Ranges` and `GenomicRanges` classes and then detail each feature of
the `plyranges` library: construction, arithmetic, restriction, summarisation,
joins, and data import/output.

# Ranges revisted

`Ranges` objects can either represent intervals of integers as `IRanges`
(which have start, end and width attributes)
or represent genomic intervals (which have additional attributes, sequence name,
and strand) as `GRanges`. In addition, both types of `Ranges` can store information
about their intervals as metadata columns (for example GC content 
over a genomic interval). 

`Ranges` objects follow the tidy data principle: each row
of a `Ranges` object corresponds to an interval, while each column will represent
a variable about that interval, and generally each object will represent a
single unit of observation (like gene annotations). 

Consequently, `Ranges` objects provide a powerful representation for reasoning
about genomic data. In this vignette, you will learn more about `Ranges` objects
and how via grouping, restriction and summarisation you can perform common data
tasks. 


# Constructing Ranges
To construct an `IRanges` we require there are at least two columns that represent at either a 
starting coordinate, finishing coordinate or the width of the interval. To
construct a `GRanges` we require a column that represents that sequence name (
contig or chromosome id), and an optional column to represent the strandedness
of an interval. 

```{r}
suppressPackageStartupMessages(library(plyranges))
set.seed(100)
df <- data.frame(start=c(2:-1, 13:15), 
                 width=c(0:3, 2:0))

# produces IRanges
rng <- df %>% Ranges()
rng

# seqname is required for GRanges, metadata is automatically kept
grng <- df %>% 
  transform(seqnames = sample(c("chr1", "chr2"), 7, replace = TRUE),
         strand = sample(c("+", "-"), 7, replace = TRUE),
         gc = runif(7)) %>% 
  Ranges()

grng
```

# Arithmetic on Ranges

Sometimes you want to modify a genomic interval by altering the width of the 
interval while leaving the start, end or midpoint of the coordinates unaltered. 
This is achieved with the `set_width` verb along with `anchor_*` adverbs.
```{r}
rng <- Ranges(data.frame(start=c(1, 2, 3), end=c(5, 2, 8)))
grng <- Ranges(data.frame(start=c(1, 2, 3), end=c(5, 2, 8), 
                          seqnames = "seq1",
                          strand = c("+", "*", "-")))
set_width(rng, 10)
set_width(anchor_start(rng), 10)
set_width(anchor_end(rng), 10)
set_width(anchor_center(rng), 10)
set_width(anchor_3p(grng), 10) # leave negative strand fixed
set_width(anchor_5p(grng), 10) # leave positve strand fixed
```

Similarly, you can modify the width of an interval using the `stretch` verb.
Without anchoring, this function will extend the interval in either direction
by an integer amount. With anchoring, either the start, end or midpoint are
preserved. 

```{r}
rng2 <- stretch(anchor_center(rng), 10)
rng2
stretch(anchor_end(rng2), 10)
stretch(anchor_start(rng2), 10)
stretch(anchor_3p(grng), 10)
stretch(anchor_5p(grng), 10)
```

`*Ranges` can be shifted left or right. If strand information is available 
we can also shift upstream or downstream. 

```{r}
shift_left(rng, 10)
shift_right(rng, 10)
shift_upstream(grng, 10)
shift_downstream(grng, 10)
```

# Grouping Ranges

`plyranges` introduces a new class of `Ranges` called `RangesGrouped`, 
this is a similiar idea to the grouped `data.frame\tibble` in `dplyr`. 
Note that grouping does not change the 
structure of a `Ranges` object only how certain functions act on it.

Grouping can act on either the core components or the metadata columns.

```{r}
grng <- data.frame(seqnames = sample(c("chr1", "chr2"), 7, replace = TRUE),
         strand = sample(c("+", "-"), 7, replace = TRUE),
         gc = runif(7),
         start = 1:7,
         width = 10) %>%
  Ranges()

grng_by_strand <- grng %>%
  group_by(strand)

grng_by_strand
```

# Restricting Ranges

The verb `filter` can be used to restrict rows in the Ranges.
Note that grouping will cause the `filter` to act within each group 
of the data.
```{r}
grng %>% filter(gc < 0.3)
# filtering by group 
grng_by_strand %>% filter(gc == max(gc)) 
```

We also provide the convience methods `filter_by_overlaps` and 
`filter_by_non_overlaps` for restricting by overlapping ranges.

```{r}
ir0 <- data.frame(start = c(5,10, 15,20), width = 5) %>%
  Ranges()
ir1 <- data.frame(start = 2:6, width = 3:7) %>%
  Ranges()
ir0
ir1
ir0 %>% filter_by_overlaps(ir1)
ir0 %>% filter_by_non_overlaps(ir1) 
```

# Joins, or another way at looking at overlaps between Ranges

We can think about finding overlaps as a type of join between two `*Ranges`
where we are using the intervals as keys. Of most use are the 
`join_overlap_inner` and `join_overlap_left` functions. The former will return
a `Ranges` object where the start, end, and width coordinates correspond to the amount
of  any overlap. By default, the width of the input ranges is added as metadata.
This allows downstreaming filtering by the amount of overlap.

```{r}
join_overlap_inner(ir0, ir1)
```

The `join_overlap_left` method will add the coordinates of the right hand
ranges that overlap those ranges on the left. Compared with `filter_by_overlaps`
above, the overlap join expands the ranges to give information about each range
on the right hand side that overlaps those on the left. We also provide
a convienence method called `find_overlaps` that computes the same result.

```{r}
join_overlap_left(ir0, ir1)
```

We also provide methods for finding, nearest, preceding or following ranges.
These methods nest a ranges column upon returning (maybe better to return just
coordinates?).

```{r}
join_nearest(ir0, ir1)
join_follow(ir0, ir1)
join_precede(ir0, ir1) # nothing precedes returns empty ranges
join_precede(ir1, ir0)
```

For `GRanges` objects by default strand is not considered when performing
overlap joins. To include strand when finding overlaps use append the prefix
`directed`. To restrict overlapping ranges to those within the query range
use the prefix `within`.

It's also possible to group by overlaps. Using this approach we can count the
number of overlaps that are greater than 0. 

```{r}
grp_by_olap <- ir0 %>% 
  group_by_overlaps(ir1)
grp_by_olap
grp_by_olap %>%
  mutate(n_overlaps = length(query))
```

Of course we can also add overlap counts via the `count_overlaps` function.

```{r}
ir0 %>%
  mutate(n_overlaps = count_overlaps(., ir1))
```

# Summarising Ranges

The `summarise` function will return a tibble because the information required
to return a _*Ranges_ object is lost. It is often most useful to use `summarise`
in combination with the `group_by` family of functions. 

```{r}
ir1 <- ir1 %>%
  mutate(gc = runif(length(.)))

ir0 %>% 
  group_by_overlaps(ir1) %>%
  summarise(gc = mean(gc))
```

# Data Import/Output

We provide convienence functions via `rtracklayer` 
for reading/writing the following data formats from/to _*Ranges_ objects.

* BED: `read/write_bed`
* BEDGraph: `read/write_bedgraph`
* GFF(1-3): `read/write_gff(1-3)`
* BigWig: `read/write_bw`
* Wig: `read/write_wig`
* narrowPeaks: `read/write_narrowpeaks`

# Appendix

```{r}
sessionInfo()
```

