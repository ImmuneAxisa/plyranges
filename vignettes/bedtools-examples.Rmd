---
title: "Using plyranges to perform common genomic data wrangling tasks"
author: "Stuart Lee"
package: plyranges
date: "`r Sys.Date()`"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::md_document:
    variant: markdown_github
abstract: A fluent interface to `Ranges` classes.
vignette: >
  %\VignetteIndexEntry{data-wrangling}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE)
```

# Introduction

Here we introduce the `plyranges` API for manipulating genomic data. 
The examples follow the [HelloRanges tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf). The aim is to show how common analysis 
tasks that are usually undertaken using `bedtools` can be performed interactively
using the `plyranges` API. Throughout this tutorial we will highlight how
the `bedtools`, `HelloRanges` and `plyranges` API differ. 

The `plyranges` API attempts to be type-consistent, that is if you apply
a `plyranges` function to a _Ranges_ object it should return a _Ranges_ object.
This means that intermittant Bioconductor classes such as `Rle` objects are
hidden away from the user, and the user can focus on the table-like structure
of ordinary _Ranges_ objects. A _Ranges_ object, in particular a _GRanges_ object
resembles a BED file and has columns to represent the chromomsome, start, end,
and strand information. It can also contain additional columns called metadata
containing information about the rows (i.e an exon name or a measurement).

# Data

The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

```

# Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function, allowing
us to obtain annotation information about each chromosome.
```{r}
suppressPackageStartupMessages(library(plyranges))
cpg <- read_bed(cpg_bed, genome_info = "hg19")
cpg

exons <- read_bed(exons_bed, genome_info = get_genome_info(cpg))
exons
```

# Intersections and Overlaps

A useful operation on two _Ranges_ is to identify where they intersect. By 
default `bedtools` will return the region of intersection between two genomic
tracks. In `plyranges` the intersect operation is a type of overlap join, that is
we are finding the common genomic intervals that overlap between the two tracks.

In `plyranges` this is termed an left overlap join:
```{r}
intersect_rng <- join_overlap_inner(cpg, exons)
intersect_rng
```

In the `HelloRanges` API (we also see the `bedtools` code here) the equivalent 
operation is:
```{r}
suppressPackageStartupMessages(library(HelloRanges))
code <- bedtools_intersect("-a cpg.bed -b exons.bed -g hg19")
code
```

## Keeping the original features
By default an overlap join will keep the information in both the query and
subject ranges.

## Computing the amount of overlap
To compute the amount of overlap we store the width of the intersecting ranges
as an additional column using the `mutate` operator.

```{r}
intersect_rng <- intersect_rng %>% 
  mutate(overlap_width = width)
```

The equivalent bedtools/HelloRanges command is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -wo")
```

## Counting the number of overlaps
To add the count of the number of times each cpg island overlaps an exon we can
use `mutate` with the `count_overlaps` function.

```{r}
cpg %>% 
  mutate(overlaps = count_overlaps(., exons))
```

The equivalent bedtools operation is

```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -c")
```

## Excluding by overlaps

We can use `filter` along with the infix operator `%over` to only
include CpG islands that do not overlap any exons.
```{r}
cpg %>% 
  filter_by_non_overlaps(., exons)
```

The equivalent bedtools operation is
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -v")
```

## Excluding by fraction of overlap

A common operation is to filter ranges by the fraction they overlap a
given query or subject. We can achieve this with an overlap inner join and mutate. Since an overlap inner join will keep the width of the original query
ranges we can combine it with filter. In this example we filter
ranges where the proportion of overlap on cpg islands is less than half.

```{r}
olap <- join_overlap_inner(cpg, exons) %>% 
  filter(width / width.x  >= 0.5)
olap
```

The equivalent bedtools code is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -f 0.5 -wo")
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `set_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `set_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}
cvg <- exons %>% 
  set_coverage() %>% 
  filter(score > 0)
cvg

bedtools_genomecov("-i exons.bed -g hg19.genome -bg")
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations along with
`left_join`. 

First, we compute the 
coverage over the exons and construct a `tibble` from the genome build 
information using `select` with `.drop_ranges = FALSE`.

```{r cv-hist0}
suppressPackageStartupMessages(library(dplyr))
cvg <- exons %>% set_coverage()
# convert the sequence annotation to a tibble
hg19 <- get_genome_info(cvg) %>%  
 select(seqnames, width, .drop_ranges = TRUE)
```

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Then we join the resulting `tibble`
to the annotation `tibble` called `hg19`. Note that in the sums we have coerced integer variables to doubles to avoid overflow.

```{r cv-hist1}

cvg_hist_by_seq <- cvg %>%
  group_by(seqnames, score) %>%
  summarise(count = sum(as.numeric(width))) %>%  
  left_join(., hg19, by = "seqnames") %>% 
  mutate(fraction = count / width)

cvg_hist_by_seq

```

Similarly for the genome-wide 
coverage histogram, we perform the same operation but do not group over
`seqnames`. Finally we bind the resulting `tibbles` together.

```{r cvhist2}
cvg_hist_total <- cvg %>%
  group_by(score) %>% 
  summarise(count = sum(as.numeric(width))) %>% 
  mutate(seqnames = "genome") %>%
  left_join(.,
            hg19 %>% 
              summarise(width = sum(as.numeric(width))) %>% 
              mutate(seqnames = "genome")) %>%
  mutate(fraction = count / width)

cvg_hist_total

cvg_hist <- bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

Although this is slightly more verbose than the `bedtools` or `HelloRanges` approach the `plyranges` code makes the actions being performed on the input
`Ranges` explicit:

```{r}
bedtools_genomecov("-i exons.bed -g hg19.genome")
```
# Composing pipelines 

## Yet another overlaps example

Here we perform another example where we chain a filter and then
find overlapping ranges between two ranges. In
this example we reduce the exons to have zero and then find the ranges that
overlap between the filtered exon ranges and the cpg islands. 

```{r}
overlaps <- exons %>% 
  filter(score == 0L) %>% 
  join_overlap_inner(.,  cpg) 

overlaps
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf.

```{r}
cvg_over_exons <- exons %>% 
  set_coverage() %>%
  join_overlap_inner(., cpg) %>%
  mutate(total = sum(as.numeric(width))) %>% 
  group_by(score) %>%
  summarise(count = sum(as.numeric(width)),
            fraction = count / unique(total)) 

cvg_over_exons

plot(1 - cumsum(fraction) ~ score, data = cvg_over_exons, 
     xlim = c(0,25), 
     type= "l", 
     xlab = "coverage", 
     ylab = "fraction of bp > coverage")

```
