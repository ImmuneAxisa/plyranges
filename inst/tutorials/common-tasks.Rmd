---
title: "Using plyranges and GenomicRanges to perform common genomic data wrangling tasks"
author: "Stuart Lee and Michael Lawrence"
date: "`r Sys.Date()`"
output:
  html_document::
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  fig.path = "./figures/"
)

# -- pacakges
library(dplyr)
library(ggbio)
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

# Introduction

This tutorial will show you how to think about and perform common genomic data 
wrangling tasks using the using the [plyranges]() and [GenomicRanges]() 
Bioconductor packages. These packages represent genomic data using the 
_GRanges_ data structure, which provides a powerful abstraction for working
with measurements or annotations along genomic regions. In this tutorial
you will use _GRanges_ object to construct workflows to

- read data from common formats like BED 
- find overlaps between different sets of genomic regions
- compute coverage and related summaries

## Who is this tutorial is for?

If you are an R beginner or new to the Bioconductor ecosystem, this tutorial
provides a comprehensive overview of one of the most important data structures
in Bioconductor, _GRanges_. We show you how to think of this data structure
as a special kind of table and perform all kinds of operations on it.

If you are familiar with the tidyverse suite of packages, then the operations
and workflows we will develop will look somewhat familiar to you. However, due 
to the complexity of genomics data, plyranges develops a new grammar based
on the tidyverse to meet the needs of the computational biologist. 

We assume you know what a data.frame is and have some knowledge
of vector types in R.

The examples and and exercises are based on the [HelloRanges package tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf).
If you are familiar with bedtools, this is an excellent resource for learning
how similar operations are performed with Bioconductor packages.

## Setup 

You will need R (version 3.5 or greater) with the following packages installed:

```{r packages, eval = FALSE}
# CRAN
library(dplyr)
library(ggplot2)
# Bioconductor
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

If you do not have these packages you can install them as follows:

```{r packages-install, eval = FALSE}
install.packages("dplyr")
install.packages("ggplot2")
 # -> Bioconductor packages are installed with this package
install.packages("BiocManager")
# then use the install function from BiocManager 
BiocManager::install(c("GenomicRanges", "plyranges", "HelloRangesData"))
```


# Introducing GRanges

The GRanges is a fundamental data structure used in the Bioconductor ecosystem. 
It is very similar to the base R data.frame but with appropriate
semantics for a genomics experiment: it has fixed columns
for the chromosome, start and end coordinates, and the strand, along
with an arbitrary set of additional columns, consisting of
measurements or metadata specific to the data type or experiment.

```{r GRanges, echo = FALSE, fig.cap="An illustration of a GRanges data object for a single sample from an RNA-seq experiment. The core components of the object include a seqnames column (representing the chromosome), a ranges column which consists of start and end coordinates for a genomic region, and a strand identifier (either positive, negative, or unstranded). Metadata are included as columns to the right of the dotted line as annotations (gene-id) or range level covariates (score).", out.width="\\textwidth"}
knitr::include_graphics("./Lee_Plyranges/GRanges.png")
```


GRanges balances flexibility with formal
constraints, so that it is applicable to virtually any genomic
workflow, while also being semantically rich enough to support
high-level operations on genomic ranges.

We can create a GRanges from an ordinary data.frame with plyranges using
the `as_granges` function:

```{r}
library(plyranges, quietly = TRUE)
genes <- data.frame(seqnames = "VI", 
                    start = c(3322, 3030, 1437,  5066, 6426, 836),
                    end = c(3846, 3338, 2615, 5521, 7565, 1363),
                    strand = c("-", "-", "-", "+", "+", "+"),
                    gene_id=c("YFL064C", "YFL065C", "YFL066C", 
                              "YFL063W", "YFL062W", "YFL067W"),
                    gc = runif(6),
                    score = rbinom(6, size = 3, p = 0.1),
                    stringsAsFactors = FALSE)
genes <- as_granges(genes)

genes
```

You might notice a few  differences between how the `genes` GRanges
object is printed compared to an ordinary data.frame or tibble.  

The measurements/annotation columns like gene_id, gc and score are placed
on the right hand side of the "|". These are referred to as metadata columns;
they are not strictly required to construct a GRanges object but are useful
for providing biological context.

The required part of a GRanges object are left of the "|" 
character. These are the seqnames column, the ranges (start, end, width) column,
and the strand column. 

You may have also noticed that underneath each column name is the type of
that column. The metadata columnns are of some usual base R types like 
`character`, `numeric`, and `integer` but the core columns may be
unfamilar. The seqnames and strand column are (factor) `Rle` columns.
`Rle` stands for run length encoding, and refers to how a column is stored.
For now, there is no harm in thinking about these as ordinary factors.

The ranges column is an `IRanges` which really consists 
of three columns: the start, end and width coordinates of the range. 
This becomes apparent if you look back to our original data.frame - the start
and end columns from there are just the start and end intervals of the ranges 
column. 

Do not be concerned if this a bit confusing for now, once we start
playing with our GRanges object, everything will become clearer.


# GRanges transformation and import

Once you have obtained data from an experiement or a public repository,
you often want to compute summaries, create new columns, modify the
genomic regions or just rearrange the data. Here you will learn how 
to achieve these tasks using the plyranges:

* Modify, subset, and aggregate genomic data with the `mutate()`, 
`filter()`, and `summarise()`.
* Modify genomic regions with the `mutate()`...
* And  while fixing the start/end/center coordinates with the `anchor_*` family
of functions.
* Sort genomic ranges with `arrange()`.
* Merge all overlapping and adjacent genomic regions with `reduce_ranges()`.
* Merge the end points of all genomic regions with `disjoin_ranges()`.

Any of the above operations can be performed on subsets of the
data with `group_by()`.

## Getting started

To begin we will test out some of these operations using a 
GRanges object obtained from a BED file
containing annotated exons from RefSeq from the hg19 genome build. 
To load the file as GRanges we can simply use the `read_bed` function from
plyranges.

```{r load-bed}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")

# our genome build
build <- genome_info("hg19")

build

exons <- read_bed(exons_bed, 
                  genome_info = build)
exons

cpg <- read_bed(cpg_bed,
                genome_info = build)
```

The `genome_info()` function automatically propagates the reference
annotations from the hg19 reference as a GRanges. This is important for
ensuring the integrity of any operations involving modifications to 
genomic regions, like overlaps or nearest neighbours. 

## Filter ranges with `filter()`

We can `filter()` ranges based on column values being `TRUE`. This
requries passing the ranges, along with one or more logical expressions.

For example, we can restrict exons to those that are on the
the X chromosome:

```{r filter-01}
filter(exons, seqnames == "chrX")
```

Multiple conditions can be composed together within a call to filter by 
seperating the expressions with a comma. To restrict exons to those 
that are on the X chromosome *AND* on the positive strand:

```{r filter-02}
filter(exons, seqnames == "chrX", strand == "+")
```

This is equivalent to
```{r filter-03}
filter(exons, seqnames == "chrX" & strand == "+")
```

But not the same as filtering exons to those on the X chromosome or 
positively stranded

```{r}
filter(exons, seqnames == "chrX" | strand == "+")
```

For a comprehensive overview of all R's logical operators see [__section
5.2.2 of R for Data Science__](https://r4ds.had.co.nz/transform.html#filter-rows-with-filter).

### Overlap based filtering

We can also restrict ranges by overlaps using  `filter_by_overlaps()`, 
or exclude non overlapping features using `filter_by_non_overlaps()`.

To see how these work it'll be useful to load another GRanges object, 
this time from a BED file containing CpG islands.

```{r cpg}
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")

cpg <- read_bed(cpg_bed, 
                genome_info = build)
cpg
```

To find exons that do not overlap any cpg islands we 
```{r}
filter_by_non_overlaps(exons, cpg)
```

Or we could find the cpg islands that are overlapped by exons 

```{r}
filter_by_overlaps(cpg, exons)
```

## Add metadata with `mutate()`

To add the count of the number of times each cpg island overlaps an exon we can
use `mutate` with the `count_overlaps` function.

```{r}
cpg %>% 
  mutate(overlaps = count_overlaps(., exons))
```


## Modify genomic regions with `mutate()` and `anchor()`


## Summarise over metadata with `summarise()`


## Summarise over the genome with `reduce_ranges()` and `disjoin_ranges()`


## Composing workflows with the pipe `%>%`


## Grouped operations with `group_by()`



# Intersections and Overlaps

A useful operation on two _Ranges_ is to identify where they intersect. By 
default `bedtools` will return the region of intersection between two genomic
tracks. In `plyranges` the intersect operation is a type of overlap join, that is
we are finding the common genomic intervals that overlap between the two tracks.

In `plyranges` this is termed an intersect overlap join:
```{r}
intersect_rng <- join_overlap_intersect(cpg, exons)
intersect_rng
```

In the `HelloRanges` API (we also see the `bedtools` code here) the equivalent 
operation is:
```{r}
suppressPackageStartupMessages(library(HelloRanges))
code <- bedtools_intersect("-a cpg.bed -b exons.bed -g hg19")
code
```

## Keeping the original features
By default an overlap join will keep the information in both the query and
subject ranges.

## Computing the amount of overlap
To compute the amount of overlap we store the width of the intersecting ranges
as an additional column using the `mutate` operator.

```{r}
intersect_rng <- intersect_rng %>% 
  mutate(overlap_width = width)
```

The equivalent bedtools/HelloRanges command is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -wo")
```

## Counting the number of overlaps


The equivalent bedtools operation is

```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -c")
```



# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `compute_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `compute_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}
cvg <- exons %>% 
  compute_coverage() %>% 
  filter(score > 0)
cvg

bedtools_genomecov("-i exons.bed -g hg19.genome -bg")
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations along with
`left_join`. 

First, we compute the 
coverage over the exons and construct a `DataFrame` from the genome build 
information using `select` with `.drop_ranges = FALSE`.

```{r cv-hist0}
suppressPackageStartupMessages(library(dplyr))
cvg <- exons %>% compute_coverage()
# convert the sequence annotation to a data.frame 
hg19 <- get_genome_info(cvg) %>%  
 select(seqnames, width, .drop_ranges = TRUE) %>%
  as.data.frame()
```

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Then we join the resulting `tibble`
to the annotation `tibble` called `hg19`. Note that in the sums we have coerced integer variables to doubles to avoid overflow.

```{r cv-hist1}

cvg_hist_by_seq <- cvg %>%
  group_by(seqnames, score) %>%
  summarise(count = sum(as.numeric(width))) %>% 
  as.data.frame() %>%
  left_join(., hg19) %>% 
  mutate(fraction = count / width)

cvg_hist_by_seq

```

Similarly for the genome-wide 
coverage histogram, we perform the same operation but do not group over
`seqnames`. Finally we bind the resulting `tibbles` together.

```{r cvhist2}
cvg_hist_total <- cvg %>%
  group_by(score) %>% 
  summarise(count = sum(as.numeric(width))) %>%
  as.data.frame() %>%
  mutate(seqnames = "genome") %>%
  left_join(.,
            hg19 %>% 
              summarise(width = sum(as.numeric(width))) %>% 
              mutate(seqnames = "genome") %>%
              as.data.frame()) %>%
  mutate(fraction = count / width)

cvg_hist_total

cvg_hist <- bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

Although this is slightly more verbose than the `bedtools` or `HelloRanges` approach the `plyranges` code makes the actions being performed on the input
`Ranges` explicit:

```{r}
bedtools_genomecov("-i exons.bed -g hg19.genome")
```

# Composing pipelines 

## Yet another overlaps example

Here we perform another example where we find exons with no coverage that
overlap cpg islands. To compose a chain first we compute the coverage
then use a filter to restrict to zero coverage ranges. Then we
perfrom an inner overlap join to find which cpg islands overlap the exonic
regions with zero coverage.

```{r}
overlaps <- exons %>% 
  compute_coverage() %>% 
  filter(score == 0L) %>% 
  join_overlap_intersect(.,  cpg) 

overlaps
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf.

```{r}
cvg_over_exons <- exons %>% 
  compute_coverage() %>%
  join_overlap_inner(., cpg) %>%
  mutate(total = sum(as.numeric(width))) %>% 
  group_by(score) %>%
  summarise(count = sum(as.numeric(width)),
            fraction = count / unique(total)) 

cvg_over_exons

plot(1 - cumsum(fraction) ~ score, data = cvg_over_exons, 
     xlim = c(0,25), 
     type= "s", 
     xlab = "coverage", 
     ylab = "fraction of bp > coverage")

```


