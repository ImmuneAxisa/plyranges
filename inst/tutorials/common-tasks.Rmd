---
title: "Using plyranges and GenomicRanges to perform common genomic data wrangling tasks"
author: "Stuart Lee and Michael Lawrence"
date: "`r Sys.Date()`"
output:
  html_document::
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  warning = FALSE,
  message = FALSE,
  fig.path = "./figures/"
)

# -- pacakges
library(dplyr)
library(ggplot2)
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

# Introduction

This tutorial will show you how to think about and perform common genomic data 
wrangling tasks using the using the [plyranges]() and [GenomicRanges]() 
Bioconductor packages. These packages represent genomic data using the 
_GRanges_ data structure, which provides a powerful abstraction for working
with measurements or annotations along genomic regions. In this tutorial
you will use _GRanges_ object to construct workflows to

- read data from common formats like BED 
- find overlaps between different sets of genomic regions
- compute coverage and related summaries
- visualise summary results


## Who is this tutorial is for?

If you are an R beginner or new to the Bioconductor ecosystem, this tutorial
provides a comprehensive overview of one of the most important data structures
in Bioconductor, _GRanges_. We show you how to think of this data structure
as a special kind of table and perform all kinds of operations on it.

If you are familiar with the tidyverse suite of packages, then the operations
and workflows we will develop will look somewhat familiar to you. However, due 
to the complexity of genomics data, plyranges develops a new grammar based
on the tidyverse to meet the needs of the computational biologist. 

The examples and and exercises are based on the [HelloRanges package tutorial](http://bioconductor.org/packages/release/bioc/vignettes/HelloRanges/inst/doc/tutorial.pdf).
If you are familiar with bedtools, this is an excellent resource for learning
how similar operations are performed with Bioconductor packages.

## Setup 

You will need R (version 3.5 or greater) with the following packages installed:

```{r packages, eval = FALSE}
# CRAN
library(dplyr)
library(ggplot2)
# Bioconductor
library(GenomicRanges)
library(plyranges)
library(HelloRangesData)
```

If you do not have these packages you can install them as follows:

```{r packages-install, eval = FALSE}
install.packages("dplyr")
install.packages("ggplot2")
 # -> Bioconductor packages are installed with this package
install.packages("BiocManager")
# then use the install function from BiocManager 
BiocManager::install(c("GenomicRanges", "plyranges", "HelloRangesData"))
```


# Introducing GRanges


## Ceci n'est pas une pipe

## Data 
The data we use for these examples are exported by the `HelloRangesData` 
package. For more details see that [package's vignette](http://bioconductor.org/packages/release/data/experiment/vignettes/HelloRangesData/inst/doc/intro.pdf). 

For most examples in this tutorial we will use 
the RefSeq exons and CpG island annotations from the hg19 genome build.
```{r bed-files}
exons_bed <- system.file("extdata", "exons.bed", package="HelloRangesData")
cpg_bed <- system.file("extdata", "cpg.bed", package = "HelloRangesData")
```

## Data Import: Reading BED files

To load the exons file as a _GRanges_ object we use the `read_bed` function.
We supply the genome build as an additional argument to this function, allowing
us to obtain annotation information about each chromosome.
```{r}
cpg <- read_bed(cpg_bed, genome_info = "hg19")
cpg

exons <- read_bed(exons_bed, genome_info = get_genome_info(cpg))
exons
```



# Intersections and Overlaps

A useful operation on two _Ranges_ is to identify where they intersect. By 
default `bedtools` will return the region of intersection between two genomic
tracks. In `plyranges` the intersect operation is a type of overlap join, that is
we are finding the common genomic intervals that overlap between the two tracks.

In `plyranges` this is termed an intersect overlap join:
```{r}
intersect_rng <- join_overlap_intersect(cpg, exons)
intersect_rng
```

In the `HelloRanges` API (we also see the `bedtools` code here) the equivalent 
operation is:
```{r}
suppressPackageStartupMessages(library(HelloRanges))
code <- bedtools_intersect("-a cpg.bed -b exons.bed -g hg19")
code
```

## Keeping the original features
By default an overlap join will keep the information in both the query and
subject ranges.

## Computing the amount of overlap
To compute the amount of overlap we store the width of the intersecting ranges
as an additional column using the `mutate` operator.

```{r}
intersect_rng <- intersect_rng %>% 
  mutate(overlap_width = width)
```

The equivalent bedtools/HelloRanges command is:
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -wo")
```

## Counting the number of overlaps
To add the count of the number of times each cpg island overlaps an exon we can
use `mutate` with the `count_overlaps` function.

```{r}
cpg %>% 
  mutate(overlaps = count_overlaps(., exons))
```

The equivalent bedtools operation is

```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -c")
```

## Excluding by overlaps

We can use `filter_by_non_overlaps` to include CpG islands that do not overlap 
any exons.
```{r}
cpg %>% 
  filter_by_non_overlaps(., exons)
```

The equivalent bedtools operation is
```{r}
bedtools_intersect("-a cpg.bed -b exons.bed -g hg19 -v")
```

# Computing Genomic Coverage

Often we are interested in counting the number of features over
an entire genome that overlap each other. In `plyranges` this is
done with the `compute_coverage` function in combination with other functions
to manipulate the results. This function will always return a new _Ranges_ 
object with a column called score. Any other variables associated with the
input _Ranges_ will be dropped.

## Coverage Vector

By default, `compute_coverage` is equivalent to `bedtools genomecov -bga` and
hence will return scores equal to zero. Filtering all scores above zero
is equivalent to `bedtools genomecov -bg`:
```{r cv}
cvg <- exons %>% 
  compute_coverage() %>% 
  filter(score > 0)
cvg

bedtools_genomecov("-i exons.bed -g hg19.genome -bg")
```

## Coverage histogram

We can construct a histogram over all seqeunces in a genome 
using the `group_by` and `summarise` operations along with
`left_join`. 

First, we compute the 
coverage over the exons and construct a `DataFrame` from the genome build 
information using `select` with `.drop_ranges = FALSE`.

```{r cv-hist0}
suppressPackageStartupMessages(library(dplyr))
cvg <- exons %>% compute_coverage()
# convert the sequence annotation to a data.frame 
hg19 <- get_genome_info(cvg) %>%  
 select(seqnames, width, .drop_ranges = TRUE) %>%
  as.data.frame()
```

Then to count the number of bases corresponding to a score we sum over
the width of each range in each chromosome. Then we join the resulting `tibble`
to the annotation `tibble` called `hg19`. Note that in the sums we have coerced integer variables to doubles to avoid overflow.

```{r cv-hist1}

cvg_hist_by_seq <- cvg %>%
  group_by(seqnames, score) %>%
  summarise(count = sum(as.numeric(width))) %>% 
  as.data.frame() %>%
  left_join(., hg19) %>% 
  mutate(fraction = count / width)

cvg_hist_by_seq

```

Similarly for the genome-wide 
coverage histogram, we perform the same operation but do not group over
`seqnames`. Finally we bind the resulting `tibbles` together.

```{r cvhist2}
cvg_hist_total <- cvg %>%
  group_by(score) %>% 
  summarise(count = sum(as.numeric(width))) %>%
  as.data.frame() %>%
  mutate(seqnames = "genome") %>%
  left_join(.,
            hg19 %>% 
              summarise(width = sum(as.numeric(width))) %>% 
              mutate(seqnames = "genome") %>%
              as.data.frame()) %>%
  mutate(fraction = count / width)

cvg_hist_total

cvg_hist <- bind_rows(cvg_hist_by_seq, cvg_hist_total)
cvg_hist
```

Although this is slightly more verbose than the `bedtools` or `HelloRanges` approach the `plyranges` code makes the actions being performed on the input
`Ranges` explicit:

```{r}
bedtools_genomecov("-i exons.bed -g hg19.genome")
```

# Composing pipelines 

## Yet another overlaps example

Here we perform another example where we find exons with no coverage that
overlap cpg islands. To compose a chain first we compute the coverage
then use a filter to restrict to zero coverage ranges. Then we
perfrom an inner overlap join to find which cpg islands overlap the exonic
regions with zero coverage.

```{r}
overlaps <- exons %>% 
  compute_coverage() %>% 
  filter(score == 0L) %>% 
  join_overlap_intersect(.,  cpg) 

overlaps
```

We can also compute the coverage histogram of exons over cpg islands
and then plot results as an ecdf.

```{r}
cvg_over_exons <- exons %>% 
  compute_coverage() %>%
  join_overlap_inner(., cpg) %>%
  mutate(total = sum(as.numeric(width))) %>% 
  group_by(score) %>%
  summarise(count = sum(as.numeric(width)),
            fraction = count / unique(total)) 

cvg_over_exons

plot(1 - cumsum(fraction) ~ score, data = cvg_over_exons, 
     xlim = c(0,25), 
     type= "s", 
     xlab = "coverage", 
     ylab = "fraction of bp > coverage")

```


